const fetch = require("node-fetch");
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson } = require('../lib/functions')
const { cmd, commands } = require("../lib/command");
const yts = require("yt-search");
const config = require("../settings");
const cheerio = require('cheerio');
const axios = require("axios");
const prefix = config.PREFIX || ".";
const { Buffer } = require('buffer');
const { igdl, ttdl } = require('ruhend-scraper');
const fg = require('api-dylux');
const mimeTypes = require('mime-types');
const gis = require("g-i-s");
const { generateWAMessageFromContent, proto, prepareWAMessageMedia } = require('@whiskeysockets/baileys');
//const prefix = config.PREFIX || ".";
const sadiya_apikey = 'sadiya-key-666';
const shan_apikey = 'ae56006bcfe029bd';
const sadiya_md_footer = '> *„ÄΩÔ∏èade By Dinuwh Bbh*';
const desc = 'DINUWH-HTO';





cmd({
  pattern: "gimg",
  react: "üò´",
  desc: "Google Image Search via g-i-s",
  category: "search",
  use: ".gimg dog",
  filename: __filename
}, async (conn, m, msg, { q, reply }) => {
  if (!q) return reply("üîç ‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä: .gimg cat");

  try {
    gis(q, async (error, results) => {
      if (error || !results || results.length === 0) return reply("üò¢ ‡∂ö‡∑í‡∑É‡∑í‡∂∏ ‡∂¥‡∑ä‚Äç‡∂ª‡∂≠‡∑í‡∂µ‡∂Ω‡∂∫‡∂ö‡∑ä ‡∑Ñ‡∂∏‡∑î ‡∂±‡∑ú‡∑Ä‡∑í‡∂±‡∑í!");

      const top3 = results.slice(0, 3);
      const cards = [];

      for (let img of top3) {
        const media = await prepareWAMessageMedia(
          { image: { url: img.url } },
          { upload: conn.waUploadToServer }
        );

        cards.push({
          header: proto.Message.InteractiveMessage.Header.fromObject({
            title: q.substring(0, 30) + ' üîç',
            hasMediaAttachment: true,
            ...media
          }),
          nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
            buttons: [{
              name: "cta_url",
              buttonParamsJson: JSON.stringify({
                display_text: "üåê View Image",
                url: img.url,
                merchant_url: img.url
              })
            }]
          })
        });
      }

      const msgContent = await generateWAMessageFromContent(m.chat, {
        ephemeralMessage: {
          message: {
            interactiveMessage: proto.Message.InteractiveMessage.fromObject({
              body: { text: `üñºÔ∏è Google Image Results for *"${q}"*` },
              carouselMessage: { cards }
            })
          }
        }
      }, { userJid: m.chat, quoted: m });

      await conn.relayMessage(m.chat, msgContent.message, { messageId: msgContent.key.id });
    });
  } catch (e) {
    console.error(e);
    return reply("üí• ‡∂ö‡∑ë‡∑Ä‡∑ô ‡∂¥‡∂ö‡∑ù. ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.");
  }
});


/*
cmd(
  {
    pattern: 'twitter',
    alias: ['x', 'twit', 'twitterdl', 'tw'],
    react: '‚ù§Ô∏è‚Äçü©π',
    desc: 'Download from Twitter',
    category: 'download',
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      if (!q) {
        return await reply('*‚ùå Please give me twitter url*');
      }
      
      // Call API to get twitter video info
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      // Prepare caption with title
      const caption =
        '\`‰πÇ Ôº§ùöíÔΩéÔΩïÔΩóÔΩà –ß—Ç Ôº§ÔΩèÔΩóÔΩé‚ü©‚ü©‚ü©\`\n‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n*‚òÖ| Title :* ' +
        (apiResponse.result.desc || '');
  if (config.MODE === 'nonbutton') {
  const sections = [
  {
    title: "üìπ ùêïùê¢ùêùùêûùê® ùêñùê¢ùê≠ùê° ùêíùêÉ",
    rows: [
      {
        title: "1.1",
        rowId: `${prefix}twsd ${q}`,
        description: 'SD Normal Video üìπ'
      },
      {
        title: "1.2",
        rowId: `${prefix}twsdptv ${q}`,
        description: '\`SD video Note üìπ\`'
      },
      {
        title: "1.3",
        rowId: `${prefix}twsddoc ${q}`,
        description: 'SD Document Video üìÑ'
      }
    ] 
  },
  {
    title: "üéûÔ∏è ùêïùê¢ùêùùêûùê® ùêñùê¢ùê≠ùê° ùêáùêÉ",
    rows: [
      {
        title: "2.1",
        rowId: `${prefix}twhd ${q}`,
        description: 'HD Normal Video üìπ'
      },
     {
        title: "2.2",
        rowId: `${prefix}twhdptv ${q}`,
        description: '\`HD Video Note üìπ\`'
      }, 
      {
        title: "2.3",
        rowId: `${prefix}twhddoc ${q}`,
        description: 'HD Document Video üìÑ'
      }
    ]
  },
  {
    title: "üéß ùêÄùêÆùêùùê¢ùê® ùêéùê©ùê≠ùê¢ùê®ùêßùê¨",
    rows: [
      {
        title: "3.1",
        rowId: `${prefix}twaud ${q}`,
        description: 'Audio With Normal File üéµ'
      },
      {
        title: "3.2",
        rowId: `${prefix}twauddoc ${q}`,
        description: '\`Audio With Document File üìÑ\`'
      },
      {
        title: "3.3",
        rowId: `${prefix}twaudptt ${q}`,
        description: 'Audio With Voice Note üé§'
      }
    ]
  }
];
const listMessage = {
  caption: caption,
  image: { url: apiResponse.result.thumb },
  footer: '> *„ÄΩÔ∏èade By Dinuwh Bbh*',
  title: '',
  buttonText: '> *‚óéReply Below Number ‚á≤‚óé*',
  sections
};

return await conn.replyList(from, listMessage, { quoted: msg });
	//button
} if (config.MODE === 'button') {
      const listData = {
  title: "ùêïùê¢ùêùùêûùê® ùêíùêûùê•ùêûùêúùê≠ùê¢ùê®ùêß „ÉÑ",
  sections: [
    {
      title: "‚•• Sd Qulity ·¥†…™·¥Ö·¥á·¥è ·¥Ñ·¥è ü ü·¥á·¥Ñ·¥õ…™·¥è…¥ ‚á≤",
      rows: [
        {
          title: "SD Normal Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}twsd ${q}`
        },
        {
          title: "SD Document Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}twsddoc ${q}`
        },
	{
          title: "SD Video Note",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}twsdptv ${q}`
	}
      ]
    },
    {
      title: "‚•• Hd Qulity ·¥†…™·¥Ö·¥á·¥è ·¥Ñ·¥è ü ü·¥á·¥Ñ·¥õ…™·¥è…¥ ‚á≤",
      rows: [
        {
          title: "HD Normal Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}twhd ${q}`
        },
	{
          title: "HD Document Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}twhddoc ${q}`
        },
	{
          title: "HD Video Note",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}twhdptv ${q}`
        }
        
      ]
    }
  ]
};
const listData2 = {
        title: "ùêÄùêÆùêùùê¢ùê® ùêíùêûùê•ùêûùêúùê≠ùê¢ùê®ùêß „ÉÑ",
        sections: [{
          title: "Twitter Audio Down Section üéß",
          rows: [
            
            {
              title: "\`Twitter Audio With Normal\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}twaud ${q}`
            },
            {
              title: "\`Twitter Audio With Document\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}twauddoc ${q}`
            },
            {
              title: "\`Twitter Audio With Voice Note\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}twaudptt ${q}`
            }
          ]
        }]
      };

      return await conn.sendMessage(from, {
      image: { url: apiResponse.result.thumb },
       caption: caption,
       footer: "> *„ÄΩÔ∏èade By Dinuwh Bbh*",
        buttons: [
          {
            buttonId: "action",
            buttonText: { displayText: "üîò" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData),
            },
          },
          {
            buttonId: "action",
            buttonText: { displayText: "üîò" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData2),
            },
          }
        ],
        headerType: 1,
        viewOnce: true,
      }, { quoted: msg });
    }

  } catch (e) {
    console.error(e);
    reply(`‚ùå Error: ${e.message}`);
  }
});

      
// Handler for SD video download from Twitter
cmd(
  {
    pattern: 'twsd',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          video: { url: apiResponse.result.video_sd },
          mimetype: 'video/mp4',
          caption: 'SD VIDEO ‚úÖ\n\n' + sadiya_md_footer,
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);


cmd(
  {
    pattern: 'twsdptv',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          video: { url: apiResponse.result.video_sd },
          mimetype: 'video/mp4',
          ptv: 'true',
          caption: 'SD VIDEO ‚úÖ\n\n' + sadiya_md_footer,
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);

cmd(
  {
    pattern: 'twsddoc',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          document: { url: apiResponse.result.video_sd },
          mimetype: 'video/mp4',
          fileName: 'twitter_sd_video.mp4',
          caption: 'üìÅ SD Twitter Video\n\n' + sadiya_md_footer,
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);

// Handler for HD video download from Twitter
cmd(
  {
    pattern: 'twhd',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          video: { url: apiResponse.result.video_hd },
          mimetype: 'video/mp4',
          caption: 'HD VIDEO ‚úÖ\n\n' + sadiya_md_footer,
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);

cmd(
  {
    pattern: 'twhdptv',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          video: { url: apiResponse.result.video_hd },
          mimetype: 'video/mp4',
	  ptv: 'true',
          caption: 'HD VIDEO ‚úÖ\n\n' + sadiya_md_footer,
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);

cmd(
  {
    pattern: 'twhddoc',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          document: { url: apiResponse.result.video_hd },
          mimetype: 'video/mp4',
          fileName: 'twitter_hd_video.mp4',
          caption: 'üìÅ HD Twitter Video\n\n' + sadiya_md_footer,
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);

// Handler for audio download from Twitter
cmd(
  {
    pattern: 'twaud',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          audio: { url: apiResponse.result.audio },
          mimetype: 'audio/mpeg',
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);


cmd(
  {
    pattern: 'twaudptt',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          audio: { url: apiResponse.result.audio },
          mimetype: 'audio/mpeg',
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);




cmd(
  {
    pattern: 'twauddoc',
    dontAddCommandList: true,
    filename: __filename,
  },
  async (conn, msg, msgInfo, { from, prefix, quoted, body, isCmd, command, args, q, reply }) => {
    try {
      const apiResponse = await fetchJson(
        'https://sadiya-tech-apis.vercel.app/download/twitterdl?url=' + q + '&apikey=' + sadiya_apikey
      );

      await conn.sendMessage(
        from,
        {
          document: { url: apiResponse.result.audio },
          mimetype: 'audio/mpeg',
          fileName: 'twitter_audio.mp3',
          caption: 'üéß Twitter Audio\n' + config.footer
        },
        { quoted: msgInfo }
      );
    } catch (err) {
      console.log(err);
      reply("‚ùå *I Couldn't find anything. Please try again later...*");
      await conn.sendMessage(
        conn.user.jid,
        { text: '‚ùó *Error Info:* ' + err },
        { quoted: msgInfo }
      );
    }
  }
);



//yttttt

cmd({
  pattern: "song",
  alias: "ytmp3",
  react: "üéµ",
  desc: "Download Song",
  category: "download",
  filename: __filename,
}, async (robin, mek, m, { from, q, prefix, reply }) => {
  try {
    if (!q) return reply("\`Give Me SONG NAME OR LINK || ‡∂±‡∂∏‡∂ö‡∑ä ‡∂Ø‡∑í‡∂∫‡∂±‡∑äüòì‚ù§Ô∏è\`");

    const search = await yts(q);
    if (!search.videos.length) return reply("\`‚ùå Video not found!\`");
    const data = search.videos[0];

    const cap = `\`‰πÇ Ôº§ùöíÔΩéÔΩïÔΩóÔΩà –ß—Ç Ôº§ÔΩèÔΩóÔΩé‚ü©‚ü©‚ü©\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

* \`‚ú¶ ùöÉùöíùöùùöïùöé\`     :  _*${data.title}*_
\`‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\` 

* \`‚ú¶ ùô≥ùöûùöõùöäùöùùöíùöòùöó\`  : _*${data.timestamp} (${data.seconds} sec)*_  
* \`‚ú¶ ùöÑùöôùöïùöòùöäùöçùöéùöç\`  : _${data.ago}_  
* \`‚ú¶ Channel\`   : *_${data.author.name}_*
* \`‚ú¶ ùöÖùöíùöéùö†ùöú\`     : _${data.views}_
* \`‚ú¶ ùöÑùöÅùôª\`       : *_${data.url}_*

\`‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
‚îÇ üé∂ *∆íœÉ‚Ñì‚ÑìœÉœâ œÖ—ï –ºœÖ—ïŒπ¬¢ ¬¢–ΩŒ±Œ∑Œ∑—î‚Ñì* üßö‚Äç‚ôÇÔ∏è  
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
üîó https://whatsapp.com/channel/0029Vb3mqn5H5JLuJO3s3Z1J

> *Send You Want Song Formate ‚§µÔ∏è*`;

    // ‚ú≥Ô∏è If nonbutton mode
if (config.MODE === 'nonbutton') {
  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: `${prefix}ytaud ${data.url}`, description: '\`‚ù≤ Audio File ‚ù≥\` üéß'},
	    {title: "2", rowId: `${prefix}ytdoc ${data.url}`, description: '\`‚ù≤ Document File ‚ù≥\` üìÑ'} ,
            {title: "3", rowId: `${prefix}ytvoice ${data.url}`, description: '\`‚ù≤ Voice Note (ptt) ‚ù≥\` üé§'} ,
            {title: "4", rowId: `${prefix}devilv ${data.url}`, description: '\`‚ù≤ Video File (mp4) ‚ù≥\` üìΩÔ∏è'} ,
	]
    } 
]
const listMessage = {
caption: cap,
image: { url: data.thumbnail },  // <-- use YouTube thumbnail here
footer: '> „ÄΩÔ∏èade By Dinuwh Bbh',
title: '',
buttonText: '> *‚óéPower Full Whatsapp bot Make By Dinuwh‚óé*',
sections
}
	
return await robin.replyList(from, listMessage ,{ quoted : mek })

	//button
if (config.MODE === 'button') {
  const listData = {
    title: "‚óé ùô≤ùô∑ùôæùôæùöÇ ùôµùôæùöÅùôºùô∞ùöÉùô¥ ‚óé",
    sections: [{
      title: "DINUWH MD OPTIONS",
      rows: [
        {
          title: "[Audio üéß]",
          description: "Download as audio\n„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}ytaud ${data.url}`
        },
        {
          title: "[Document üìÅ]",
          description: "Download as document\n„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}ytdoc ${data.url}`
        },
        {
          title: "[Voice (ptt) üí°]",
          description: "Download as Voice Note\n„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}ytvoice ${data.url}`
        }
      ]
    }]
  };

  return await robin.sendMessage(from, {
    image: { url: data.thumbnail },
    caption: cap,
    footer: "> „ÄΩÔ∏èade By Dinuwh Bbh",
    buttons: [
      {
        buttonId: "action",
        buttonText: { displayText: "üîò Choose Song Type" },
        type: 4,
        nativeFlowInfo: {
          name: "single_select",
          paramsJson: JSON.stringify(listData),
        },
      },
    ],
    headerType: 1,
    viewOnce: true,
  }, { quoted: mek });
}
//videoinfosendjs=========================-====--%=%=%--%-%-%-$-#-#-#=##=$-$-#9#9=9.0=9.0-$839#=$-$738#=738.0$-%*$8##-%748$=$-%7$8$=$-%-

//Voice j=%=%=%==%=%=%==%=%=%==%%%=%==%=%=
cmd({
  pattern: "ytvoice",
  //alias: ["ytmp3"],
  desc: "Download YouTube song (no caption, audio only)",
  category: "download",
  react: "üé§",
  filename: __filename,
}, async (robin, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("SONG NAME üòí?");
    const search = await yts(q);
    if (!search.videos.length) return reply("Yt search Failü§ß!");
    const data = search.videos[0];
    const api = `https://manul-official-new-api-site.vercel.app/convert?mp3=${encodeURIComponent(data.url)}&apikey=Manul-Official`;
    const result = await fetchJson(api);
    const dl_url = result.data.url;
    await robin.sendMessage(m.chat, {
      audio: { url: dl_url },
      mimetype: 'audio/mpeg',
      ptt: true,
      fileName: `${data.title}.mp3`
    }, { quoted: m });
  } catch (e) {
    reply("*üõë ERROR! Something went wrong*");
    console.log(e);
  }
});
//ytdoc=====
cmd({
  pattern: "ytdoc",
 // alias: ["ytmp3"],
  desc: "Download YouTube song as document only",
  category: "download",
  react: "üìÑ",
  filename: __filename,
}, async (robin, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("üìÅ Song name Error");
    const search = await yts(q);
    if (!search.videos.length) return reply("Yt search Failü§ß!");
    const data = search.videos[0];
    const api = `https://manul-official-new-api-site.vercel.app/convert?mp3=${encodeURIComponent(data.url)}&apikey=Manul-Official`;
    const result = await fetchJson(api);
    const dl_url = result.data.url;
    await robin.sendMessage(m.chat, {
      document: { url: dl_url },
      mimetype: 'audio/mpeg',
      fileName: `${data.title}.mp3`
    }, { quoted: m });
  } catch (e) {
    reply("‚ùå *ERROR! Something went wrong*");
    console.log(e);
  }
});
//=======
cmd({
  pattern: "ytaud",
  //alias: ["ytmp3"],
  desc: "Download YouTube song (no caption, audio only)",
  category: "download",
  react: "üé∂",
  filename: __filename,
}, async (robin, mek, m, { q, reply }) => {
  try {
    if (!q) return reply("SONG NAME üòí?");
    const search = await yts(q);
    if (!search.videos.length) return reply("Yt search Failü§ß!");
    const data = search.videos[0];
    const api = `https://manul-official-new-api-site.vercel.app/convert?mp3=${encodeURIComponent(data.url)}&apikey=Manul-Official`;
    const result = await fetchJson(api);
    const dl_url = result.data.url;
    await robin.sendMessage(m.chat, {
      audio: { url: dl_url },
      mimetype: 'audio/mpeg',
      ptt: false,
      fileName: `${data.title}.mp3`
    }, { quoted: m });
  } catch (e) {
    reply("*üõë ERROR! Something went wrong*");
    console.log(e);
  }
});


//Music End Now Video Plugins ‚òù All Erro Fixed all Up Plugins



cmd({
  pattern: "video",
  alias: "ytmp4",
  react: "üéµ",
  desc: "Download Song",
  category: "download",
  filename: __filename,
}, async (robin, mek, m, { from, q, prefix, reply }) => {
  try {
    if (!q) return reply("\`Give Me  NAME OR LINK || ‡∂±‡∂∏‡∂ö‡∑ä ‡∂Ø‡∑í‡∂∫‡∂±‡∑äüòì‚ù§Ô∏è\`");

    const search = await yts(q);
    if (!search.videos.length) return reply("\`‚ùå Video not found!\`");
    const data = search.videos[0];

    const cap = `\`‰πÇ Ôº§ùöíÔΩéÔΩïÔΩóÔΩà –ß—Ç Ôº§ÔΩèÔΩóÔΩé‚ü©‚ü©‚ü©\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

* \`‚ú¶ ùöÉùöíùöùùöïùöé\`     :  _*${data.title}*_
\`‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\` 

* \`‚ú¶ ùô≥ùöûùöõùöäùöùùöíùöòùöó\`  : _*${data.timestamp} (${data.seconds} sec)*_  
* \`‚ú¶ ùöÑùöôùöïùöòùöäùöçùöéùöç\`  : _${data.ago}_  
* \`‚ú¶ Channel\`   : *_${data.author.name}_*
* \`‚ú¶ ùöÖùöíùöéùö†ùöú\`     : _${data.views}_
* \`‚ú¶ ùöÑùöÅùôª\`       : *_${data.url}_*

\`‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
‚îÇ üé∂ *∆íœÉ‚Ñì‚ÑìœÉœâ œÖ—ï –ºœÖ—ïŒπ¬¢ ¬¢–ΩŒ±Œ∑Œ∑—î‚Ñì* üßö‚Äç‚ôÇÔ∏è  
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
üîó https://whatsapp.com/channel/0029Vb3mqn5H5JLuJO3s3Z1J

> *Send You Want Video Formate ‚§µÔ∏è*`;

    


if (config.MODE === 'nonbutton') {
  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: `${prefix}normalv ${data.url}`, description: '\`‚ù≤ Normal Type Videos ‚ù≥\` üìΩÔ∏è'},
	    {title: "2", rowId: `${prefix}documentv ${data.url}`, description: '\`‚ù≤ Document Type Videos ‚ù≥\` üìÑ'} ,
            
	]
    } 
]
const listMessage = {
caption: cap,
image: { url: data.thumbnail },  // <-- use YouTube thumbnail here
footer: '> „ÄΩÔ∏èade By Dinuwh Bbh',
title: '',
buttonText: '> *‚óéPower Full Whatsapp bot Make By Dinuwh‚óé*',
sections
}
	
return await robin.replyList(from, listMessage ,{ quoted : mek })

	//button
} if (config.MODE === 'button') {
      const listData = {
        title: "‚óé ùô≤ùô∑ùôæùôæùöÇ Video ùôµùôæùöÅùôºùô∞ùöÉùô¥ ‚óé",
        sections: [{
          title: "Video Type OPTIONS",
          rows: [
            {
              title: "*‚ù® Normal Quality Files ‚ù©*",
              description: "*Normal  Type Videos*\n„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}normalv ${data.url}`
            },
            
            {
              title: "*‚ù® Document Quality Files ‚ù©*",
              description: "*Document Type Videos*\n„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}documentv ${data.url}`
            }
          ]
        }]
      };

      return await robin.sendMessage(from, {
        image: { url: data.thumbnail },
        caption: cap,
        footer: "> „ÄΩÔ∏èade By Dinuwh Bbh",
        buttons: [
          {
            buttonId: `${prefix}normalv ${data.url}`,
            buttonText: { displayText: "`\`‚ù≤ Normal Quality Files üìΩÔ∏è‚ù≥\``" },
            type: 1
          },
          {
            buttonId: `${prefix}documentv ${data.url}`,
            buttonText: { displayText: "`\`‚ù≤ Document Quality Files üìÑ‚ù≥\``" },
            type: 1
          },

          {
            buttonId: "action",
            buttonText: { displayText: "üîò Choose Type" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData),
            },
          },
        ],
        headerType: 1,
        viewOnce: true,
      }, { quoted: mek });
    }
  } catch (e) {
    console.error(e);
    reply(`‚ùå Error: ${e.message}`);
  }
});


//Auto Song Js=3=3.03=3.03=3.03=3.033=3.0333=3.03333=3.033333=3.033333=3.0333333=3.033333=3.0333333=3.03333333=3.03333333

let autoSenders = {};
const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];

cmd(
  {
    pattern: "autosongd",
    desc: "Auto-send random YouTube MP3 to a JID every 30 seconds based on keyword",
    category: "download",
    react: "üéß",
    filename: __filename,
  },
  async (robin, mek, m, { q, reply }) => {
    try {
      if (!q.includes("&")) return reply("üìå Example: .autosongd boot song & 9476xxxxxxx@s.whatsapp.net");

      const [keyword, jid] = q.split("&").map(i => i.trim());

      if (!keyword || !jid) return reply("‚ùå Missing song keyword or JID.");

      if (autoSenders[jid]) {
        return reply("‚è≥ Auto-song sender is already running for this JID.");
      }

      reply(`‚úÖ Auto-song sender activated for *${jid}* using keyword: *"${keyword}"*. Songs will be sent every 30 seconds.`);

      autoSenders[jid] = setInterval(async () => {
        try {
          const search = await yts(keyword);
          if (!search.videos.length) return;

          const data = getRandom(search.videos);
          const ytUrl = data.url;

          const api = `https://yt-five-tau.vercel.app/download?q=${ytUrl}&format=mp3`;
          const { data: apiRes } = await axios.get(api);

          if (!apiRes?.status || !apiRes.result?.download) return;

          const result = apiRes.result;

          const caption = `üéß *Auto Song From Dinuwh*\n\nüìù *Title:* ${result.title}\nüïí *Duration:* ${data.timestamp}\nüìÖ *Uploaded:* ${data.ago}\n\n_üîó Powered by Dinuwh MD Bot_`;

          await robin.sendMessage(
            jid,
            { image: { url: result.thumbnail }, caption },
            { quoted: mek }
          );

          await robin.sendMessage(
            jid,
            {
              audio: { url: result.download },
              mimetype: "audio/mpeg",
              ptt: true,
            },
            { quoted: mek }
          );
        } catch (err) {
          console.error("[AutoSong Error]", err);
        }
      }, 30 * 60 * 1000); // every 30 seconds
    } catch (err) {
      console.error(err);
      reply("‚ùå An unexpected error occurred!");
    }
  }
);


cmd(
  {
    pattern: "stopautosong",
    desc: "Stop AutoSong for a given JID",
    category: "download",
    react: "üõë",
    filename: __filename,
  },
  async (robin, mek, m, { q, reply }) => {
    if (!q) return reply("üìå Example: .stopautosong 9476xxxxxxx@s.whatsapp.net");

    const jid = q.trim();
    if (autoSenders[jid]) {
      clearInterval(autoSenders[jid]);
      delete autoSenders[jid];
      reply(`‚úÖ Auto-song sender has been stopped for *${jid}*.`);
    } else {
      reply("‚ùå No auto-song sender is active for this JID.");
    }
  }
);

//3=3.03=3.033=3.0333=3.03333=3.033333=3.033333=3.03333=3.03333=3.033333
//TIKTOK TIKTOK TIKTOK TIKTOK TIKTOK TIKTOK TIKTOK TIKTOK TIKTOK TIKTOK 
//3=3.03=3.033=3.0333=3.03333=3.03333=3.03333=3.033332=3.0333322=3.03333223


cmd({
  pattern: "tikaud",
 // alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üéß',
  desc: "Download TikTok video (WM) + Audio",
  category: "download",
  use: '.tiktok <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*Url Error*.");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();


    // Send audio as voice message (PTT)
    await conn.sendMessage(from, { audio: { url: data.music }, mimetype: 'audio/mp4', ptt: false }, { quoted: mek });

  } catch (e) {
    console.log(e);
    return reply(`*Download Error*\n\n${e.message}`);
  }
});

//=======TiktokAud-Document


cmd({
  pattern: "tikauddoc",
//  alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üéß',
  desc: "Download TikTok audio (MP3 as document)",
  category: "download",
  use: '.tiktoksv <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*üîó Url Error*");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();

    // Send audio as document
    await conn.sendMessage(from, {
      document: { url: data.music },
      mimetype: 'audio/mp3',
      fileName: `${data.title || 'tiktok'}.mp3`,
      caption: '> *„ÄΩÔ∏èade By Dinuwh Bbh*'
    }, { quoted: mek });

  } catch (e) {
    console.log(e);
    return reply(`*Download Error*\n\n${e.message}`);
  }
});

//=====Tik-Aud-Ptt=3=3.03=3.03=3.033=3.03333


cmd({
  pattern: "tikaudptt",
//  alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üéß',
  desc: "Download TikTok video (WM) + Audio",
  category: "download",
  use: '.tiktok <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*Url Error*");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();


    // Send audio as voice message (PTT)
    await conn.sendMessage(from, { audio: { url: data.music }, mimetype: 'audio/mp4', ptt: true }, { quoted: mek });

  } catch (e) {
    console.log(e);
    return reply(`*Download Error*\n\n${e.message}`);
  }
});

//=====Tik-Watermark-norml


cmd({
  pattern: "tikwm",
 // alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üìπ',
  desc: "Download TikTok video (WM) + Audio",
  category: "download",
  use: '.tiktok <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*Url Error*");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();

    // Send watermark video
    await conn.sendMessage(from, { video: { url: data.watermark }, caption: "> *„ÄΩÔ∏èade By Dinuwh Bbh*" }, { quoted: mek });


  } catch (e) {
    console.log(e);
    return reply(`‚ùå Error\n\n${e.message}`);
  }
});

//=Watermark-doc=======


cmd({
  pattern: "tikwmdoc",
 // alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üìπ',
  desc: "Download TikTok video (WM) as Document",
  category: "download",
  use: '.tiktoksv <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*Url Error*");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();

    // Send watermark video as document
    await conn.sendMessage(from, {
      document: { url: data.watermark },
      mimetype: 'video/mp4',
      fileName: `${data.title || 'tiktok'}.mp4`,
      caption: '> *„ÄΩÔ∏èade By Dinuwh Bbh*'
    }, { quoted: mek });

  } catch (e) {
    console.log(e);
    return reply(`‚ùå Error\n\n${e.message}`);
  }
});

//Tik-Nonwatermark-norml



cmd({
  pattern: "tiknowm",
 // alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üìπ',
  desc: "Download TikTok video (WM) + Audio",
  category: "download",
  use: '.tiktok <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*Url Error*");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();

    // Send watermark video
    await conn.sendMessage(from, { video: { url: data.no_watermark }, caption: "> *„ÄΩÔ∏èade By Dinuwh Bbh*" }, { quoted: mek });

    

  } catch (e) {
    console.log(e);
    return reply(`‚ùå Error\n\n${e.message}`);
  }
});

//==tik-no wm Doc



cmd({
  pattern: "tiknowmdoc",
 // alias: ["tt", "ttdl", "tiktokdl"],
  react: 'üìπ',
  desc: "Download TikTok video (No Watermark) as Document",
  category: "download",
  use: '.tiktoksv <tiktok url>',
  filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
  try {
    if (!q) return await reply('*Error*');
    if (!q.includes("tiktok")) return await reply("*Url Error*");

    const res = await fetch(`https://darksadasyt-tiktokdl.vercel.app/api/tiktok?q=${q}`);
    const data = await res.json();

    // Send video as document (no watermark)
    await conn.sendMessage(from, {
      document: { url: data.no_watermark },
      mimetype: 'video/mp4',
      fileName: `${data.title || 'tiktok'}.mp4`,
      caption: '> *„ÄΩÔ∏èade By Dinuwh Bbh*'
    }, { quoted: mek });

  } catch (e) {
    console.log(e);
    return reply(`*‚ùå Error*\n\n${e.message}`);
  }
});


//====3==3=3=3.03=3.03=3.03=3.033-=3-



cmd({
  pattern: "tt",
  alias: ["ttinfo", "ttdetails", "tiktok"],
  react: 'üîé',
  desc: "Get TikTok video details only.",
  category: "tools",
  use: ".tiok <TikTok video URL>",
  filename: __filename
}, async (conn, mek, m, { from, reply, args }) => {
  try {
    const tiktokUrl = args[0];
    if (!tiktokUrl || !tiktokUrl.includes("tiktok.com")) {
      return reply('```ü•≤ ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∑Ä‡∂Ω‡∂Ç‡∂ú‡∑î TikTok ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±.\n‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä: .tiok https://www.tiktok.com/@user/video/123...```');
    }

    await conn.sendMessage(from, { react: { text: 'üîç', key: m.key } });

    const apiUrl = `https://api.nexoracle.com/downloader/tiktok-nowm?apikey=free_key@maher_apis&url=${encodeURIComponent(tiktokUrl)}`;
    const response = await axios.get(apiUrl);

    const { title, thumbnail, author, metrics } = response.data.result;

    const detailsMsg = `‰πÇ ·ó™I·ëé·ëå·óØ·ïº TIKTOK ·ó™O·óØ·ëé ‚ü©‚ü©‚ü©
\`‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\`

- \`D\` ·¥è·¥°…¥ ü·¥è·¥Ä·¥ÖÍú± : _${metrics.download_count}_
- \`C\` ·¥è·¥ç·¥ç·¥á…¥·¥õÍú±  : _*${metrics.comment_count}*_
- \`S\`  ú·¥Ä Ä·¥áÍú±    : _${metrics.share_count}_
- \`P\`  ü·¥Ä èÍú±     : _${metrics.play_count}_
- \`L\` …™·¥ã·¥áÍú±     : _*${metrics.digg_count}*_
- \`L\` …™…¥·¥ã      : _${tiktokUrl}_
‚ú†.A·¥ú·¥õ ú·¥è Ä :
- N…™·¥Ñ·¥ã N·¥Ä·¥ç·¥á :- *${author.nickname}*
- UÍú±·¥á Ä…¥·¥Ä·¥ç·¥á   :- *@${author.username}*

\`‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\``;

    // ‚ú≥Ô∏è If nonbutton mode
if (config.MODE === 'nonbutton') {
  const sections = [
  {
    title: "üìπ ùêïùê¢ùêùùêûùê® ùêñùê¢ùê≠ùê° ùêñùêöùê≠ùêûùê´ùê¶ùêöùê´ùê§",
    rows: [
      {
        title: "1.",
        rowId: `${prefix}tikwm ${tiktokUrl}`,
        description: '`‚ù≤ With Watermark Normal ‚ù≥` üìπ'
      },
      {
        title: "2.",
        rowId: `${prefix}tikwmdoc ${tiktokUrl}`,
        description: '`‚ù≤ With Watermark Document ‚ù≥` üìÑ'
      }
    ] },
  {
    title: "üéûÔ∏è ùêïùê¢ùêùùêûùê® ùêçùê® ùêñùêöùê≠ùêûùê´ùê¶ùêöùê´ùê§",
    rows: [
      {
        title: "3.",
        rowId: `${prefix}tiknowm ${tiktokUrl}`,
        description: '`‚ù≤ No Watermark Normal ‚ù≥` üìπ'
      },
      {
        title: "4.",
        rowId: `${prefix}tiknowmdoc ${tiktokUrl}`,
        description: '`‚ù≤ No Watermark Document ‚ù≥` üìÑ'
      }
    ]
  },
  {
    title: "üéß ùêÄùêÆùêùùê¢ùê® ùêéùê©ùê≠ùê¢ùê®ùêßùê¨",
    rows: [
      {
        title: "5.",
        rowId: `${prefix}tikaud ${tiktokUrl}`,
        description: '`‚ù≤ Audio With Normal File ‚ù≥` üéµ'
      },
      {
        title: "6.",
        rowId: `${prefix}tikauddoc ${tiktokUrl}`,
        description: '`‚ù≤ Audio With Document File ‚ù≥` üìÑ'
      },
      {
        title: "7.",
        rowId: `${prefix}tikaudptt ${tiktokUrl}`,
        description: '`‚ù≤ Audio With Voice Note ‚ù≥` üé§'
      }
    ]
  }
];
const listMessage = {
caption: detailsMsg,
image: { url:thumbnail },  // <-- use YouTube thumbnail here
footer: '> *„ÄΩÔ∏èade By Dinuwh Bbh*',
title: '',
buttonText: '> *‚óéReply Below Number ‚á≤‚óé*',
sections
}
	
return await conn.replyList(from, listMessage ,{ quoted : mek })

	//button
} if (config.MODE === 'button') {
      const listData = {
  title: "ùêïùê¢ùêùùêûùê® ùêíùêûùê•ùêûùêúùê≠ùê¢ùê®ùêß „ÉÑ",
  sections: [
    {
      title: "üìΩÔ∏è Non-Watermark ·¥†…™·¥Ö·¥á·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö·¥á Ä ‚á≤",
      rows: [
        {
          title: "NonWaterMark Normal Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}tiknowm ${tiktokUrl}`
        },
        {
          title: "NonWaterMark Document Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}tiknowmdoc ${tiktokUrl}`
        }
      ]
    },
    {
      title: "üíß With-Watermark ·¥†…™·¥Ö·¥á·¥è ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö·¥á Ä ‚á≤",
      rows: [
        {
          title: "WithWaterMark Normal Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}tikwm ${tiktokUrl}`
        },
        {
          title: "WithWaterMark Document Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}tikwmdoc ${tiktokUrl}`
        }
      ]
    }
  ]
};
const listData2 = {
        title: "ùêÄùêÆùêùùê¢ùê® ùêíùêûùê•ùêûùêúùê≠ùê¢ùê®ùêß „ÉÑ",
        sections: [{
          title: "TikTok Audio Down Section üéß",
          rows: [
            
            {
              title: "\`Audio With Normal\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}tikaud ${tiktokUrl}`
            },
            {
              title: "\`Audio With Document\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}tikauddoc ${tiktokUrl}`
            },
            {
              title: "\`Audio With Voice Note\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}tikaudptt ${tiktokUrl}`
            }
          ]
        }]
      };

      return await conn.sendMessage(from, {
        image: { url: thumbnail },
        caption: detailsMsg,
        footer: "> *„ÄΩÔ∏èade By Dinuwh Bbh*",
        buttons: [
          {
            buttonId: "action",
            buttonText: { displayText: "üîòe" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData),
            },
          },
          {
            buttonId: "action",
            buttonText: { displayText: "üîòe" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData2),
            },
          }
        ],
        headerType: 1,
        viewOnce: true,
      }, { quoted: mek });
    }

  } catch (e) {
    console.error(e);
    reply(`‚ùå Error: ${e.message}`);
  }
});


//Yt video ============8==========88===888-8=88==4=4=4=4=



cmd(
  {
    pattern: "144v",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*Provide a name or a YouTube link.* üé•‚ù§Ô∏è");

      // Search for the video
      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      // Video download function
      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;

          // Wait for download URL generation
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;
          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("Failed to fetch video details.");
        }
      };

      // Specify desired quality
      const quality = "144";

      // Download and send video only
      const video = await downloadVideo(url, quality);
      await robin.sendMessage(
        from,
        {
          video: video.buffer,
          caption: `üé• *${video.title}*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//==========================*=*=*=*--*-*=*=*-*==*=**=*=*==*==*=*=*=*=*=

cmd(
  {
    pattern: "240v",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*Provide a name or a YouTube link.* üé•‚ù§Ô∏è");

      // Search for the video
      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      // Video download function
      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;

          // Wait for download URL generation
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;
          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("Failed to fetch video details.");
        }
      };

      // Specify desired quality
      const quality = "240";

      // Download and send video only
      const video = await downloadVideo(url, quality);
      await robin.sendMessage(
        from,
        {
          video: video.buffer,
          caption: `üé• *${video.title}*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//==========================*=*=*=*--*-*=*=*-*==*=**=*=*==*==*=*=*=*=*=
cmd(
  {
    pattern: "360v",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*Provide a name or a YouTube link.* üé•‚ù§Ô∏è");

      // Search for the video
      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      // Video download function
      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;

          // Wait for download URL generation
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;
          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("Failed to fetch video details.");
        }
      };

      // Specify desired quality
      const quality = "360";

      // Download and send video only
      const video = await downloadVideo(url, quality);
      await robin.sendMessage(
        from,
        {
          video: video.buffer,
          caption: `üé• *${video.title}*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//==*=6=6.06=6.066=6.066=6.0666=6.06666=6.06666*=*=*==*=*=*=*=6=6.06=6.06=6.066=6.0666=6.06666=6.06666*=*==*=

cmd(
  {
    pattern: "480v",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*Provide a name or a YouTube link.* üé•‚ù§Ô∏è");

      // Search for the video
      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      // Video download function
      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;

          // Wait for download URL generation
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;
          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("Failed to fetch video details.");
        }
      };

      // Specify desired quality
      const quality = "480";

      // Download and send video only
      const video = await downloadVideo(url, quality);
      await robin.sendMessage(
        from,
        {
          video: video.buffer,
          caption: `üé• *${video.title}*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);


//=$==%=&=55=55.06=55.066=55.0666=55.0666=55.06666=55.066666=55.0666666=55.06666666=55.066666666=55.06666666666=55.06666666666

cmd(
  {
    pattern: "720v",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*Provide a name or a YouTube link.* üé•‚ù§Ô∏è");

      // Search for the video
      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      // Video download function
      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;

          // Wait for download URL generation
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;
          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("Failed to fetch video details.");
        }
      };

      // Specify desired quality
      const quality = "720";

      // Download and send video only
      const video = await downloadVideo(url, quality);
      await robin.sendMessage(
        from,
        {
          video: video.buffer,
          caption: `üé• *${video.title}*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//=$==$=$=%=%==%=%=%($(($93($($(=3=3.04=3.04=3.044=3.0444=3.04444=3.044444=3.04444=3.04444
cmd(
  {
    pattern: "1080v",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*Provide a name or a YouTube link.* üé•‚ù§Ô∏è");

      // Search for the video
      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      // Video download function
      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;

          // Wait for download URL generation
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;
          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("Failed to fetch video details.");
        }
      };

      // Specify desired quality
      const quality = "1080";

      // Download and send video only
      const video = await downloadVideo(url, quality);
      await robin.sendMessage(
        from,
        {
          video: video.buffer,
          caption: `üé• *${video.title}*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);


//=$=$-$===Document-Type

cmd(
  {
    pattern: "144vd",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*üì• Please provide a name or a YouTube link.*");

      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;

          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("üìõ Failed to fetch video details.");
        }
      };

      const quality = "144";
      const video = await downloadVideo(url, quality);

      await robin.sendMessage(
        from,
        {
          document: video.buffer,
          mimetype: "video/mp4",
          fileName: `${video.title}.mp4`,
          caption: `üé• *${video.title}*\n\n*MADE BY - DINUWH-MDüñáÔ∏è*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//=%=%=-%=%=%=%==3=3.0$==$=%=%=%=%==3=3.03=3.03=3.033=3.0333=3.03333=3.033333=3.033333

cmd(
  {
    pattern: "240vd",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*üì• Please provide a name or a YouTube link.*");

      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;

          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("üìõ Failed to fetch video details.");
        }
      };

      const quality = "240";
      const video = await downloadVideo(url, quality);

      await robin.sendMessage(
        from,
        {
          document: video.buffer,
          mimetype: "video/mp4",
          fileName: `${video.title}.mp4`,
          caption: `üé• *${video.title}*\n\n*MADE BY - DINUWH-MDüñáÔ∏è*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//=$=$=$$=$94=94.0=94.04=94.04=94.04=94.044=94.044=94.0444=94.04444=94.04444=94.044444=94.044444

cmd(
  {
    pattern: "360vd",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*üì• Please provide a name or a YouTube link.*");

      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;

          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("üìõ Failed to fetch video details.");
        }
      };

      const quality = "360";
      const video = await downloadVideo(url, quality);

      await robin.sendMessage(
        from,
        {
          document: video.buffer,
          mimetype: "video/mp4",
          fileName: `${video.title}.mp4`,
          caption: `üé• *${video.title}*\n\n*MADE BY - DINUWH-MDüñáÔ∏è*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//-$=3=3.03=3.03=3.033=3.033=3.033=2=2.02=2.022=2.0222=2.0222

cmd(
  {
    pattern: "480vd",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*üì• Please provide a name or a YouTube link.*");

      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;

          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("üìõ Failed to fetch video details.");
        }
      };

      const quality = "480";
      const video = await downloadVideo(url, quality);

      await robin.sendMessage(
        from,
        {
          document: video.buffer,
          mimetype: "video/mp4",
          fileName: `${video.title}.mp4`,
          caption: `üé• *${video.title}*\n\n*MADE BY - DINUWH-MDüñáÔ∏è*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//=33=3.03=3.03=3.033=3.033=3.0333=3.03333=3.033333=3.033333=3.0333333=3.03333333=3.033333333=3.033333333==

cmd(
  {
    pattern: "720vd",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*üì• Please provide a name or a YouTube link.*");

      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;

          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("üìõ Failed to fetch video details.");
        }
      };

      const quality = "720";
      const video = await downloadVideo(url, quality);

      await robin.sendMessage(
        from,
        {
          document: video.buffer,
          mimetype: "video/mp4",
          fileName: `${video.title}.mp4`,
          caption: `üé• *${video.title}*\n\n*MADE BY - DINUWH-MDüñáÔ∏è*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);


//=3=3.03=3.033=3.033=3.033=3.0333=3.03333=3.033333=3.0333333=3.03333333=3.03333333


cmd(
  {
    pattern: "1080vd",
    react: "üé•",
    desc: "Download YouTube Video",
    category: "download",
    filename: __filename,
  },
  async (
    robin,
    mek,
    m,
    { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }
  ) => {
    try {
      if (!q) return reply("*üì• Please provide a name or a YouTube link.*");

      const search = await yts(q);
      const data = search.videos[0];
      const url = data.url;

      const downloadVideo = async (url, quality) => {
        const apiUrl = `https://p.oceansaver.in/ajax/download.php?format=${quality}&url=${encodeURIComponent(
          url
        )}&api=dfcb6d76f2f6a9894gjkege8a4ab232222`;

        const response = await axios.get(apiUrl);

        if (response.data && response.data.success) {
          const { id, title } = response.data;
          const progressUrl = `https://p.oceansaver.in/ajax/progress.php?id=${id}`;

          while (true) {
            const progress = await axios.get(progressUrl);
            if (progress.data.success && progress.data.progress === 1000) {
              const videoBuffer = await axios.get(progress.data.download_url, {
                responseType: "arraybuffer",
              });
              return { buffer: videoBuffer.data, title };
            }
            await new Promise((resolve) => setTimeout(resolve, 5000));
          }
        } else {
          throw new Error("üìõ Failed to fetch video details.");
        }
      };

      const quality = "1080";
      const video = await downloadVideo(url, quality);

      await robin.sendMessage(
        from,
        {
          document: video.buffer,
          mimetype: "video/mp4",
          fileName: `${video.title}.mp4`,
          caption: `üé• *${video.title}*\n\n*MADE BY - DINUWH-MDüñáÔ∏è*`,
        },
        { quoted: mek }
      );

    } catch (e) {
      console.error(e);
      reply(`‚ùå Error: ${e.message}`);
    }
  }
);

//VideoDownload Main


cmd({
  pattern: "normalv",
  alias: "song",
  react: "üéµ",
  desc: "Download Song",
  category: "download",
  filename: __filename,
}, async (robin, mek, m, { from, q, prefix, reply }) => {
  try {
    if (!q) return reply("\`Give Me SONG NAME OR LINK || ‡∂±‡∂∏‡∂ö‡∑ä ‡∂Ø‡∑í‡∂∫‡∂±‡∑äüòì‚ù§Ô∏è\`");

    const search = await yts(q);
    if (!search.videos.length) return reply("\`‚ùå Video not found!\`");
    const data = search.videos[0];

    const cap = `\`‰πÇ Ôº§ùöíÔΩéÔΩïÔΩóÔΩà –ß—Ç Ôº§ÔΩèÔΩóÔΩé‚ü©‚ü©‚ü©\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

> \`‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\` 
> *Same The Old Details üò¥üñáÔ∏è*
> \`‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
‚îÇ *Select You Want Video quality* üßö‚Äç‚ôÇÔ∏è
‚îÇ *‡∂î‡∂∂‡∂ß ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂ú‡∑î‡∂´‡∑è‡∂≠‡∑ä‡∂∏‡∂ö ‡∂≠‡∂≠‡∑ä‡∑Ä‡∂∫ ‡∂≠‡∑ù‡∂ª‡∂±‡∑ä‡∂± üò¥üñáÔ∏è*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø`;

    // ‚ú≥Ô∏è If nonbutton mode
if (config.MODE === 'nonbutton') {
  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: `${prefix}144v ${data.url}`, description: '\`‚ù≤ 144p Normal Video File ‚ù≥\` üìΩÔ∏è'},
	    {title: "2", rowId: `${prefix}240v ${data.url}`, description: '\`‚ù≤ 240p Normal Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "3", rowId: `${prefix}360v ${data.url}`, description: '\`‚ù≤ 360p Normal Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "4", rowId: `${prefix}480v ${data.url}`, description: '\`‚ù≤ 480p Normal Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "5", rowId: `${prefix}720v ${data.url}`, description: '\`‚ù≤ 720p Normal Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "6", rowId: `${prefix}1080v ${data.url}`, description: '\`‚ù≤ 1080 Normal Video File ‚ù≥\` üìΩÔ∏è'} ,
	]
    } 
]
const listMessage = {
caption: cap,
image: { url: data.thumbnail },  // <-- use YouTube thumbnail here
footer: '> „ÄΩÔ∏èade By Dinuwh Bbh',
title: '',
buttonText: '> *‚óéPower Full Whatsapp bot Make By Dinuwh‚óé*',
sections
}
	
return await robin.replyList(from, listMessage ,{ quoted : mek })

	//button
} if (config.MODE === 'button') {
      const listData = {
        title: "‚óé ‚ù®ùô≤ùô∑ùôæùôæùöÇ ùöÖùô∏ùô≥ùô¥ùôæ ùöÄùöÑùô∞ùôªùô∏ùöÉùöà‚ù© ‚óé",
        sections: [{
          title: "NORMAL VIDEO OPTIONS",
          rows: [
            {
              title: "\`‚ù® 144p Normal Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Normal.Type 144p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}144v ${data.url}`
            },
            {
              title: "\`‚ù® 240p Normal Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Normal.Type 240p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}240v ${data.url}`
            },
            {
              title: "\`‚ù® 360p Normal Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Normal.Type 360p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}360v ${data.url}`
            },
            {
              title: "\`‚ù® 480p Normal Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Normal.Type 480p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}480v ${data.url}`
            },
	    {
              title: "\`‚ù® 720p Normal Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Normal.Type 720p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}720v ${data.url}`
            },
            {
              title: "\`‚ù® 1080p Normal Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Normal.Type 1080p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}1080v ${data.url}`
            }
          ]
        }]
      };

      return await robin.sendMessage(from, {
        image: { url: data.thumbnail },
        caption: cap,
        footer: "> „ÄΩÔ∏èade By Dinuwh Bbh",
        buttons: [
          
          {
            buttonId: `${prefix}dinuping`,
            buttonText: { displayText: "`[CHECK BOT SPEED üìç]`" },
            type: 1
          },

          {
            buttonId: "action",
            buttonText: { displayText: "üîò" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData),
            },
          },
        ],
        headerType: 1,
        viewOnce: true,
      }, { quoted: mek });
    }
  } catch (e) {
    console.error(e);
    reply(`‚ùå Error: ${e.message}`);
  }
});


//=======3=3.04=3.044=3.0444=3.0444=3.04444=3.044443=3.044443=3.0444434=3.04444344=3.044443444=3.0444434444

cmd({
  pattern: "documentv",
  alias: "song",
  react: "üéµ",
  desc: "Download Song",
  category: "download",
  filename: __filename,
}, async (robin, mek, m, { from, q, prefix, reply }) => {
  try {
    if (!q) return reply("\`Give Me SONG NAME OR LINK || ‡∂±‡∂∏‡∂ö‡∑ä ‡∂Ø‡∑í‡∂∫‡∂±‡∑äüòì‚ù§Ô∏è\`");

    const search = await yts(q);
    if (!search.videos.length) return reply("\`‚ùå Video not found!\`");
    const data = search.videos[0];

    const cap = `\`‰πÇ Ôº§ùöíÔΩéÔΩïÔΩóÔΩà –ß—Ç Ôº§ÔΩèÔΩóÔΩé‚ü©‚ü©‚ü©\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

> \`‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\` 
> *Same The Old Details üò¥üñáÔ∏è*
> \`‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
‚îÇ *Select You Want Video quality* üßö‚Äç‚ôÇÔ∏è
‚îÇ *‡∂î‡∂∂‡∂ß ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂ú‡∑î‡∂´‡∑è‡∂≠‡∑ä‡∂∏‡∂ö ‡∂≠‡∂≠‡∑ä‡∑Ä‡∂∫ ‡∂≠‡∑ù‡∂ª‡∂±‡∑ä‡∂± üò¥üñáÔ∏è*
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø`;

    // ‚ú≥Ô∏è If nonbutton mode
if (config.MODE === 'nonbutton') {
  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: `${prefix}144vd ${data.url}`, description: '\`‚ù≤ 144p Document Video File ‚ù≥\` üìΩÔ∏è'},
	    {title: "2", rowId: `${prefix}240vd ${data.url}`, description: '\`‚ù≤ 240p Document Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "3", rowId: `${prefix}360vd ${data.url}`, description: '\`‚ù≤ 360p Document Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "4", rowId: `${prefix}480vd ${data.url}`, description: '\`‚ù≤ 480p Document Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "5", rowId: `${prefix}720vd ${data.url}`, description: '\`‚ù≤ 720p Document Video File ‚ù≥\` üìΩÔ∏è'} ,
      {title: "6", rowId: `${prefix}1080vd ${data.url}`, description: '\`‚ù≤ 1080 Document Video File ‚ù≥\` üìΩÔ∏è'} ,
	]
    } 
]
const listMessage = {
caption: cap,
image: { url: data.thumbnail },  // <-- use YouTube thumbnail here
footer: '> „ÄΩÔ∏èade By Dinuwh Bbh',
title: '',
buttonText: '> *‚óéPower Full Whatsapp bot Make By Dinuwh‚óé*',
sections
}
	
return await robin.replyList(from, listMessage ,{ quoted : mek })

	//button
} if (config.MODE === 'button') {
      const listData = {
        title: "‚óé ‚ù®ùô≤ùô∑ùôæùôæùöÇ ùöÖùô∏ùô≥ùô¥ùôæ ùöÄùöÑùô∞ùôªùô∏ùöÉùöà‚ù© ‚óé",
        sections: [{
          title: "DOCUMENT VIDEO OPTIONS",
          rows: [
            {
              title: "\`‚ù® 144p Document Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Document.Type 144p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}144vd ${data.url}`
            },
            {
              title: "\`‚ù® 240p Document Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Document.Type 240p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}240vd ${data.url}`
            },
            {
              title: "\`‚ù® 360p Document Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Document.Type 360p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}360vd ${data.url}`
            },
            {
              title: "\`‚ù® 480p Document Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Document.Type 480p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}480vd ${data.url}`
            },
	    {
              title: "\`‚ù® 720p Document Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Document.Type 720p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh*",
              id: `${prefix}720vd ${data.url}`
            },
            {
              title: "\`‚ù® 1080p Document Video File ‚ù©\` üìΩÔ∏è",
              description: "*Download as Document.Type 1080p*\n> *„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}1080vd ${data.url}`
            }
          ]
        }]
      };

      return await robin.sendMessage(from, {
        image: { url: data.thumbnail },
        caption: cap,
        footer: "> „ÄΩÔ∏èade By Dinuwh Bbh",
        buttons: [
          
          {
            buttonId: `${prefix}ping ${data.url}`,
            buttonText: { displayText: "`[CHECK BOT SPEED üìç]`" },
            type: 1
          },

          {
            buttonId: "action",
            buttonText: { displayText: "üîò Choose Song Type" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData),
            },
          },
        ],
        headerType: 1,
        viewOnce: true,
      }, { quoted: mek });
    }
  } catch (e) {
    console.error(e);
    reply(`‚ùå Error: ${e.message}`);
  }
});
	  



//Fbbbbbb



const api = `https://nethu-api-ashy.vercel.app`;

//01.Facebook Download
cmd({
  pattern: "fb",
  react: "üé•",
  alias: ["fbbbb", "fbvideo", "fb"],
  desc: "ddesc",
  category: "download",
  use: '.facebook <facebook_url>',
  filename: __filename
},
async(conn, mek, m, {
    from, prefix, q, reply
}) => {
  try {
  if (!q) return reply("Please provide a Facebook video URL.");

  const fb = await fetchJson(`${api}/download/fbdown?url=${encodeURIComponent(q)}`);

if (!fb.result || (!fb.result.sd && !fb.result.hd)) {
  return reply("Video not found or not downloadable. Please check the URL.");
}

let result = fb.result; // <== ‡∂∏‡∑ô‡∂≠‡∂± result ‡∂ë‡∂ö assign ‡∂ö‡∂ª‡∂¥‡∂±‡∑ä

let caption = `\`‰πÇ Ôº§ùöíÔΩéÔΩïÔΩóÔΩà ùêπùõ£ Ôº§ÔΩèÔΩóÔΩé‚ü©‚ü©‚ü©\`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ


* *‚ñ£ \`T\` itle* : ${result.title || 'N/A'}
* *‚ñ£ \`D\` esc* : ${result.desc || 'N/A'}
* *‚ñ£ \`U\` RL*   : ${q}
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ú¶‚úß‚ú¶‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
‚îÇ üé∂ *∆íœÉ‚Ñì‚ÑìœÉœâ œÖ—ï –ºœÖ—ïŒπ¬¢ ¬¢–ΩŒ±Œ∑Œ∑—î‚Ñì* üßö‚Äç‚ôÇÔ∏è  
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚úø  
üîó https://whatsapp.com/channel/0029Vb3mqn5H5JLuJO3s3Z1J
`;
  if (config.MODE === 'nonbutton') {
  const sections = [
  {
    title: "üìπ ùêïùê¢ùêùùêûùê® ùêñùê¢ùê≠ùê° ùêíùêÉ",
    rows: [
      {
        title: "1",
        rowId: `${prefix}downfb_sd ${q}`,
        description: 'SD Normal Video üìπ'
      },
      {
        title: "2",
        rowId: `${prefix}downfb_sdd ${q}`,
        description: '\`SD video Note üìπ\`'
      },
      {
        title: "3",
        rowId: `${prefix}downfb_sdp ${q}`,
        description: 'SD Document Video üìÑ'
      }
    ] 
  },
  {
    title: "üéûÔ∏è ùêïùê¢ùêùùêûùê® ùêñùê¢ùê≠ùê° ùêáùêÉ",
    rows: [
      {
        title: "4",
        rowId: `${prefix}downfb_hd ${q}`,
        description: 'HD Normal Video üìπ'
      },
     {
        title: "5",
        rowId: `${prefix}downfb_hdd ${q}`,
        description: '\`HD Video Note üìπ\`'
      }, 
      {
        title: "6",
        rowId: `${prefix}downfb_hdp ${q}`,
        description: 'HD Document Video üìÑ'
      }
    ]
  },
  {
    title: "üéß ùêÄùêÆùêùùê¢ùê® ùêéùê©ùê≠ùê¢ùê®ùêßùê¨",
    rows: [
      {
        title: "7",
        rowId: `${prefix}fb_sd_audio ${q}`,
        description: 'Audio With Normal File üéµ'
      },
      {
        title: "8",
        rowId: `${prefix}fb_sd_doc ${q}`,
        description: '\`Audio With Document File üìÑ\`'
      },
      {
        title: "9",
        rowId: `${prefix}fb_sd_ptt ${q}`,
        description: 'Audio With Voice Note üé§'
      }
    ]
  }
];
const listMessage = {
  caption: caption,
  image: { url: fb.result.thumb }, // ‚úÖ fixed line
  footer: '> *„ÄΩÔ∏èade By Dinuwh Bbh*',
  title: '',
  buttonText: '> *‚óéReply Below Number ‚á≤‚óé*',
  sections
};

return await conn.replyList(from, listMessage, { quoted: mek });
	//button
} if (config.MODE === 'button') {
      const listData = {
  title: "ùêïùê¢ùêùùêûùê® ùêíùêûùê•ùêûùêúùê≠ùê¢ùê®ùêß „ÉÑ",
  sections: [
    {
      title: "‚•• Sd Qulity ·¥†…™·¥Ö·¥á·¥è ·¥Ñ·¥è ü ü·¥á·¥Ñ·¥õ…™·¥è…¥ ‚á≤",
      rows: [
        {
          title: "SD Normal Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}downfb_sd ${q}`
        },
        {
          title: "SD Document Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}downfb_sdd ${q}`
        },
	{
          title: "SD Video Note",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}downfb_sdp ${q}`
	}
      ]
    },
    {
      title: "‚•• Hd Qulity ·¥†…™·¥Ö·¥á·¥è ·¥Ñ·¥è ü ü·¥á·¥Ñ·¥õ…™·¥è…¥ ‚á≤",
      rows: [
        {
          title: "HD Normal Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}downfb_hd ${q}`
        },
	{
          title: "HD Document Video",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}downfb_hdd ${q}`
        },
	{
          title: "HD Video Note",
          description: "„ÄΩÔ∏èade By Dinuwh Bbh",
          id: `${prefix}downfb_hdp ${q}`
        }
        
      ]
    }
  ]
};
const listData2 = {
        title: "ùêÄùêÆùêùùê¢ùê® ùêíùêûùê•ùêûùêúùê≠ùê¢ùê®ùêß „ÉÑ",
        sections: [{
          title: "TikTok Audio Down Section üéß",
          rows: [
            
            {
              title: "\`Fb Audio With Normal\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}fb_sd_audio ${q}`
            },
            {
              title: "\`Fb Audio With Document\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}fb_sd_doc ${q}`
            },
            {
              title: "\`Fb Audio With Voice Note\`",
              description: "„ÄΩÔ∏èade By Dinuwh Bbh",
              id: `${prefix}fb_sd_ptt ${q}`
            }
          ]
        }]
      };

      return await conn.sendMessage(from, {
        image: { url: fb.result.thumb },
        caption: caption,
        footer: "> *„ÄΩÔ∏èade By Dinuwh Bbh*",
        buttons: [
          {
            buttonId: "action",
            buttonText: { displayText: "üîò" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData),
            },
          },
          {
            buttonId: "action",
            buttonText: { displayText: "üîò" },
            type: 4,
            nativeFlowInfo: {
              name: "single_select",
              paramsJson: JSON.stringify(listData2),
            },
          }
        ],
        headerType: 1,
        viewOnce: true,
      }, { quoted: mek });
    }

  } catch (e) {
    console.error(e);
    reply(`‚ùå Error: ${e.message}`);
  }
});
*/

